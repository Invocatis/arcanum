se
(use 'racoon.model.menu :reload) (use 'racoon.model :reload)
(racoon.model/dispatch racoon.model.menu/model)
(use 'racoon.database :reload)
(racoon.model/dispatch db-spec racoon.model.menu/model :read)
(use 'racoon.database :reload)
(racoon.model/dispatch db-spec racoon.model.menu/model :read)
(use 'racoon.database :reload)
(racoon.model/dispatch db-spec racoon.model.menu/model :read)
(use 'racoon.model.menu :reload) (use 'racoon.model :reload)
(racoon.model/dispatch db-spec racoon.model.menu/model :read)
(use 'racoon.model.menu :reload) (use 'racoon.model :reload)
(racoon.model/dispatch db-spec racoon.model.menu/model :read)
(use 'racoon.model.menu :reload) (use 'racoon.model :reload)
(racoon.model/dispatch db-spec racoon.model.menu/model :read)
(use 'racoon.model.menu :reload) (use 'racoon.model :reload)
(racoon.model/dispatch db-spec racoon.model.menu/model :read)
(use 'racoon.database :reload)
(racoon.model/dispatch db-spec racoon.model.menu/model :read)
(use 'racoon.database :reload)
(racoon.model/dispatch db-spec racoon.model.menu/model :read)
(use 'racoon.database :reload)
(racoon.model/dispatch db-spec racoon.model.menu/model :read)
(use 'racoon.model.menu :reload) (use 'racoon.model :reload)
(racoon.model/dispatch db-spec racoon.model.menu/model :read)
(use 'racoon.model.menu :reload) (use 'racoon.model :reload)
(racoon.model/dispatch db-spec racoon.model.menu/model :read)
(use 'racoon.database :reload)
(racoon.model/dispatch db-spec racoon.model.menu/model :read)
(use 'racoon.database :reload)
(racoon.model/dispatch db-spec racoon.model.menu/model :read)
(racoon.model/dispatch db-spec racoon.model.menu/model :get)
(use 'racoon.database :reload)
(racoon.model/dispatch db-spec racoon.model.menu/model :get)
(use 'racoon.database :reload)
(racoon.model/dispatch db-spec racoon.model.menu/model :get)
(source clojure.core.incubator/dissoc-in )
(source clojure.core.incubator/-?>)
defnilsafe
clojure.core.incubator/new-by-name 
(doc clojure.core.incubator/new-by-name )
(use 'racoon.server :reload)
(start)
(use 'racoon.server :reload)
(start)
(require 'ring.adapter.jetty)
(use 'racoon.server :reload)
(start )
(use 'racoon.server :reload)
(start )
(def s *1)
future
(doc future)
(doc delay)
s
(.close s)
(start )
(defmulti asdf identity)
(fn? asdf)
(ifn? 'asdf)
(ifn? :asdf)
all-ns
(all-ns)
(ns-name *ns*)
(ns-resolve 'racoon.model.menu 'model)
(ns-resolve *ns* 'model)
(use 'racoon.server :reload)
(use 'racoon.client :reload)
(use 'racoon.server :reload)
(use 'racoon.client :reload)
(use 'racoon.server :reload)
(init-models)
(use 'racoon.server :reload)
(init-models)
(use 'racoon.server :reload)
(init-models)
(use 'racoon.server :reload)
server/models
(use 'racoon.server :reload)
models
(require '[motif.core :as m])
(m/matches? [:get] [:get 1 2 3])
(m/matches? ^:! [:get] [:get 1 2 3])
(read-string "{:x 1}")
s
server
(defmulti x identity)
(type x)
(defn multifn?
  [any]
  (instance? clojure.lang.MultiFn any))
(multifn? x)
MultiFn
clojure.lang.MultiFn
s
(start)_
'#[:asdf]
'#[asdf]
'#db[asdf]
#db[asdf]
#db{:asdf 1}
#:db{:asdf 1}
#:db['asdf]
(use 'racoon.server :reload)
(start)_
(use 'racoon.server :reload)
(start)_
(def s *1)
s
(model/dispatch db/db-spec menu/model :get)
(ns-resolve 'racoon.model.menu 'model)
(use 'racoon.model.menu :reload)
(model/dispatch db/db-spec menu/model :get)
(use 'racoon.model.menu :reload)
(model/dispatch db/db-spec menu/model :get)
(use 'racoon.model.menu :reload)
(model/dispatch db/db-spec menu/model :get)
(use 'racoon.model.menu :reload)
(model/dispatch db/db-spec menu/model :get)
(use 'racoon.model.menu :reload)
(model/dispatch db/db-spec menu/model :get)
(use 'racoon.model.menu :reload) (use 'racoon.model :reload)
(model/dispatch db/db-spec menu/model :get)
(require '[transit.core])
(require '[cognitect.transit :as t])
(doc t/write)
(.stop s)
s
(use 'racoon.model.menu :reload) (use 'racoon.model :reload)
(use 'racoon.server :reload)
(start)
(use 'racoon.server :reload)
(def s *2)
s
(.stop s)
(def s (start))
(use 'racoon.server :reload)
(.stop s)
(def s (start))
(use 'racoon.server :reload)
(def s (start))
\
(use 'racoon.server :reload)
(.stop s)
(def s (start))
(use 'racoon.server :reload)
(def s (start))
(use 'racoon.server :reload)
(def s (start))
(defn restart [] (.stop s) (use 'racoon.server :reload) (def s (start)))
(restart)
(def s (start))
(defn restart [] (.stop s) (use 'racoon.server :reload) (def s (start)))
(restart)
(defn restart [] (.stop s) (use 'racoon.server :reload) (def s (start)))
(restart)
(defn restart [] (.stop s) (use 'racoon.server :reload) (def s (start)))
(restart)
(.stop s)
(restart)
(.stop s)
(restart)
(model/dispatch db/db-spec menu/model :get)
(-> *1 vals first vals first)
(use 'racoon.model.menu :reload)
(restart)
(start)
(def s *1)
(restart)
(defn restart [] (.stop s) (use 'racoon.server :reload) (def s (start)))
(restart)
s
(start)
(source start)
(def s*3)
(doc server/serve)
(defn restart [] (.stop s) (use 'racoon.server :reload) (def s (start)))
(restart)
s
(use 'racoon.server :reload)
(start)
(model/dispatch db/db-spec menu/model :get)
(start)
(model/dispatch db/db-spec menu/model :get)
(use 'racoon.database :reload)
(model/dispatch db/db-spec menu/model :get)
(restart)
(defn restart [] (.stop s) (use 'racoon.server :reload) (def s (start)))
(restart)
(defn restart [] (.stop s) (use 'racoon.server :reload) (def s (start)))
(def s nil)
(defn restart [] (.stop s) (use 'racoon.server :reload) (def s (start)))
(restart)
(def s (start s))
(def s (start))
(defn restart [] (.stop s) (use 'racoon.server :reload) (def s (start)))
(model/dispatch db/db-spec menu/model :get)
(defn restart [] (.stop s) (use 'racoon.server :reload) (def s (start)))
(def s (start))
(model/dispatch db/db-spec menu/model :get)
(restart)
(defn restart [] (.stop s) (use 'racoon.server :reload) (def s (start)))
(restart)
(doc cond->)
(cond-> inc fn? (apply 1))
(cond-> inc fn? (apply [1]))
(require '[motif.core :refer [matches?]])
(matches? [] ())
(matches? [1] ())
(matches? [] '(1))
(defn restart [] (.stop s) (use 'racoon.server :reload) (def s (start)))
(use 'racoon.model.menu :reload)
(model/dispatch model)
(use 'racoon.database :reload)
(model/dispatch db-spec model)
(model/dispatch db-spec model :get)
(use 'racoon.model.menu :reload) (use 'racoon.model :reload)
(model/dispatch db-spec model :get)
(use 'racoon.model :reload)
(model/dispatch db-spec model :get)
(model/dispatch db-spec model :get)*e
(use 'racoon.model :reload)
(model/dispatch db-spec model :get)*e
(model/dispatch db-spec model :get)
(model/dispatch db-spec model :get)*e
(use 'racoon.model :reload)
(model/dispatch db-spec model :get)*e
(model/dispatch db-spec model :get)
*e
(use 'racoon.model :reload)
*e
(model/dispatch db-spec model :get)
(use 'racoon.model :reload)
(model/dispatch db-spec model :get)
(use 'racoon.model :reload)
(model/dispatch db-spec model :get)
(use 'racoon.model :reload)
asdf
(model/dispatch db-spec model :get)
asdf
(select-spec model :get [])
model
(get-in model [:api :get])
(use 'racoon.model :reload)
(get-in model [:api :get])
(model/dispatch db-spec model :get)
(use 'racoon.model :reload)
(model/dispatch db-spec model :get)
*e
(cond-> {} fn? (apply []))
(fn? {})
(cond-> {} map? (apply []))
(cond-> {} map? println)
(cond-> [] map? println)
(cond-> 1 true inc)
(cond-> 1 (pos?) inc)
(cond-> 1 (pos? 1) inc)
(use 'racoon.model :reload)
(cond-> 1 (pos? 1) inc)
(model/dispatch db-spec model :get)
(use 'racoon.model :reload)
(model/dispatch db-spec model :get)
(model/dispatch db-spec model :get 1)
'
(defn restart [] (.stop s) (use 'racoon.server :reload) (def s (start)))
(def s (start)
(def s (start))
(defn restart [] (.stop s) (use 'racoon.server :reload) (def s (start)))
(def s (start))
(merge {:x 1} {:x 2})
1/2
(def s (start))
(source map-indexed )
(start)
(comp inc dec)
(name nil)
(defn restart [] (.stop s) (use 'racoon.server :reload) (def s (start)))
(def s (start))
(defn restart [] (.stop s) (use 'racoon.server :reload) (def s (start)))
(restart)
(def s (start))
(pr-str "asdf")
(pr "asdf")
(def s (start))
'
(restart)
(use 'artificer.server :reload)
(restart)
(start)
(model/dispatch menu/model :get)
(model/dispatch db-spec menu/model :get)
(use 'artificer.database )
(model/dispatch db-spec menu/model :get)
(def x *1)
(pprint x)
(pr-str x)
(read-string *1)
(pr-str x)
(pprint *1)
(vals x)
(map println (vals x))
(pr-str x)
(use 'artificer.model.menu :reload)
(restart)
(def s (start))
(use 'artificer.model.menu :reload)
(def s (start))
(restart)
x
(model/dispatch db-spec menu/model :get)
(use 'artificer.database )
(model/dispatch db-spec menu/model :get)
(def x *1)
(-> x vals)
(-> x vals first vals first)
(-> x vals first vals first first)
(-> x vals first vals first first pr-str)
(-> x vals first vals first first pr-str read-string)
(-> x vals (nth 2) vals first first pr-str read-string)
(-> x keys)
clojure.string/lower-case 
(model/dispatch db-spec menu/model :get)
(use 'artificer.model.menu :reload)
(restart)
(use 'artificer.model.menu :reload)
(restart)
(use 'artificer.model.menu :reload)
(restart)
(use 'artificer.model.menu :reload)
(restart)
(keyword "")
(use 'artificer.model.menu :reload)
(restart)
(use 'artificer.model.menu :reload)
(restart)
]
(.substring "asdf" 0 2)
(entrySet {})
removev
filterv
pr-str*
(doc partition)
has-nil?
(str nil)
(transient [])
nnext
(require '[flatland.ordered.map ])
(require '[flatland.ordered.map :refer [ordered-map]])
(ordered-map 1 2 3 4)
(assoc *1 1 10)
(dissoc (ordered-map 1 2 3 4) 1)
(assoc (dissoc (ordered-map 1 2 3 4) 1) 1 2)
(UUID/randomUUID)
#uuid
# uuid
random-sample 
(java.util.UUID/randomUUID)
(.replaceAll (.toString (java.util.UUID/randomUUID)) "\\-" "_")
(def x *1)
(def s (start))
(declare x)
x
(if x 1 2)
(use 'artificer.orderdmap :reload)
(use 'artificer.orderedmap :reload)
(def s (start))
(doc dotimes)
   [:button  "Invent 100 new desserts"]
(def m {:x 1 :y {:z 2}})
(assoc m :y {:z 2})
(identical? m (assoc m :y {:z 2}))
(identical? m (assoc m :y (get m :y)))
(identical? m (assoc m :y {:z 2}))
(identical? (get m :y) (get (assoc m :y {:z 2}) :y))
(= (get m :y) (get (assoc m :y {:z 2}) :y))
(identical? (get m :y) (get (assoc m :y {:z 2}) :y))
(= (get m :y) (get (assoc m :y {:z 2}) :y))
(assoc m :y {:z 2})
(require '[clojure.java.io :as io])
(io/file "asdf")
(.exists (io/file "asdf"))
(re-matches? #"[^0-9A-Za-z\\-+.\\[\\](){}]" "[A/C]")
(re-matches? #"[^0-9A-Za-z\-+.\\[\](){}]" "[A/C]")
(re-matches? #"[^0-9A-Za-z\-+.\[\](){}]" "[A/C]")
(re-matches #"[^0-9A-Za-z\-+.\[\](){}]" "[A/C]")
(clojure.string/split "[A/C]" #"[^0-9A-Za-z\-+.\[\](){}]")
(re-matches "[A/C]" #"([\[({])*([^\[\]{}()])([\])}])*")
(re-matches #"([\[({])*([^\[\]{}()])([\])}])*" "[A/C]")
(re-matches #"([\|[(|{])*([^\[\]{}()])([\]|)|}])*" "[A/C]")
(re-matches #"([\[|(|{])*([^\[\]{}()])([\]|)|}])*" "[A/C]")
(re-matches #"([\[|(|{])*.*([\]|)|}])*" "[A/C]")
(re-matches #"([\[|(|{])*(.*)([\]|)|}])*" "[A/C]")
(re-matches #"(\[|\(|\{)*([^\[\]{}()])(\]|\)|\})*" "[A/C]")
(re-matches #"(\[|\(|\{)*([^\[\]{}()])*(\]|\)|\})*" "[A/C]")
(re-matches #"(\[|\(|\{)*)*" "[A/C]")
(re-matches #"(\[|\(|\{)*" "[A/C]")
(re-matches #"(\[|\(|\{)*" "[[[[")
(re-matches #"(\[|\(|\{)*([^\[\]{}()]*)(\]|\)|\})*" "[A/C]")
(re-matches #"\[" "[")
(hash [:x 1])
(require '[tupolo.forest :as f])
(require '[tupelo.forest :as f])
(f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 "world"]])
(f/with-forest (f/new-forest) (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 "world"]]))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 "world"]])] (f/find-paths id [:a])))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 "world"]])] (f/find-paths id [:div])))
(require '[tupelo.forest :as f])
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 "world"]])] (f/find-paths id [:div])))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 "world"]])] (f/format-paths (f/find-paths id [:div]))))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {} "world"]])] (f/find-paths id [:div])))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {} "world"]])] (f/format-paths (f/find-paths id [:div]))))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {:v 1} "world"]])] (f/format-paths (f/find-paths id [:div]))))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {:v 1} "world"]])] (f/format-paths (f/find-paths id [:h1]))))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {:v 1} "world"]])] (f/format-paths (f/find-paths id [** :h1]))))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {:v 1} "world"]])] (f/format-paths (f/find-paths id [:** :h1]))))
(-> *1 first)
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {:v 1} "world"]])] (f/find-paths id [:** :h1])))
(doc f/format-paths)
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {:v 1} "world"]])] (f/find-paths id [:** :h1])))
(-> *1 ffirst f/hid->hiccup )
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {:v 1} "world"]])] (-> (f/find-paths id [:** :h1]) ffirst f/hid->hiccup )))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {:v 1} "world"]])] (-> (f/find-paths id [:** :h1]) ffirst f/hid->enlive)))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {:v 1} "world"]])] (-> (f/find-paths id [:** :h1]) ffirst f/hid->attr)))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {:v 1} "world"]])] (-> (f/find-paths id [:** :h1]) ffirst f/hid->attrs)))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {:v 1} "world"]])] (-> (f/find-paths id [:** :h1]) ffirst f/hid->leaf)))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {:v 1} "world"]])] (-> (f/find-paths id [:** :h1]) ffirst f/hid->bush)))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {:v 1} "world"]])] (-> (f/find-paths id [:** :h1]) ffirst f/hid->edn)))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {:v 1} "world"]])] (-> (f/find-paths id [:** :h1]) ffirst f/hid->attrs)))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {:v 1} "world"]])] (-> (f/find-paths id [:** :h1]) ffirst f/hid->attr)))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {:v 1} "world"]])] (-> (f/find-paths id [:** :h1]) ffirst f/hid->value)))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} [:h1 "hello"] [:h1 {:v 1} "world"]])] (-> (f/find-paths id [:** :h1]) ffirst f/hid->hiccup)))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} ([:h1 "hello"] [:h1 {:v 1} "world"]]))] (-> (f/find-paths id [:** :h1]) ffirst f/hid->hiccup)))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} ([:h1 "hello"] [:h1 {:v 1} "world"])])] (-> (f/find-paths id [:** :h1]) ffirst f/hid->hiccup)))
(time (hash [:div [:svg [:something {}] [:something-else [:blabla {:fuckall 123}]]]]))
(f/with-forest (f/new-forest) (let [id (f/add-tree-hiccup [:div {} ([:h1 "hello"] [:h1 {:v 1} "world"])])] (-> (f/find-paths id [:** :h1]) ffirst f/hid->hiccup)))
(time (hash [:div [:svg [:something {}] [:something-else [:blabla {:fuckall 123}]]]]))
2A
(time (hash [:div [:svg [:something {}] [:something-else [:blabla {:fuckall 123}]]]]))
(use 'retort.core :reload)
(trim-design {:h1 {:something :whatever}} [:h1 {:asdf 1}] nil)
(trim-design {:h1 {:something :whatever}} [:h2 {:asdf 1}] nil)
(trim-design {:h1 {:something :whatever}} [:div {:asdf 1} [:h1] nil)
(trim-design {:h1 {:something :whatever}} [:div {:asdf 1} [:h1]] nil)
(use 'retort.core :reload)
(trim-design {:h1 {:something :whatever}} [:div {:asdf 1} [:h1]] nil)
(relevant-design {:h1 {:something :whatever}} [:div {:asdf 1} [:h1]] nil)
(use 'retort.core :reload)
(relevant-design {:h1 {:something :whatever}} [:div {:asdf 1} [:h1]] nil)
(use 'retort.core :reload)
(relevant-design {:h1 {:something :whatever}} [:div {:asdf 1} [:h1]] nil)
(relevant-design {:h1 {:something :whatever}} (list [:h1]) nil)
(seq? (list))
(seq? [])
(relevant-design {:h1 {:something :whatever}} (list [:h1]) nil)
(relevant-design {:h1 {:something :whatever}} [:h1] nil)
(use 'retort.core :reload)
(relevant-design {:h1 {:something :whatever}} [:h1] nil)
(relevant-design {:h1 {:something :whatever}} (list [:h1]) nil)
(use 'retort.core :reload)
(relevant-design {:h1 {:something :whatever}} (list [:h1]) nil)
(relevant-design {:h1 {:something :whatever}} [:div {:asdf 1} [:h1]] nil)
(use 'retort.core :reload)
x
(x 1000)
(use 'retort.core :reload)
(x 1000)
(use 'retort.core :reload)
(relevant-design {:h1 {:something :whatever}} [:div {:asdf 1} [:h1]] nil)
(relevant-design {:h1 {:something :whatever}} (list [:h1]) nil)
(relevant-design {:h1 {:something :whatever}} [:h1] nil)
(relevant-design {:h1 {:something :whatever}} (list [:h1]) nil)
(use 'retort.core :reload)
(relevant-design {:h1 {:something :whatever}} [:h1] nil)
(relevant-design {:h1 {:something :whatever}} (list [:h1]) nil)
(relevant-design {:h1 {:something :whatever}} [:div {:asdf 1} [:h1]] nil)
(hiccup/children [:div {:asdf 1} [:h1]])
)
(require '[retort.hiccup :as hiccup])
(hiccup/children [:div {:asdf 1} [:h1]])
(use 'retort.core :reload)
(use 'retort.hiccup :reload)
(relevant-design {:h1 {:something :whatever}} [:div {:asdf 1} [:h1]] nil)
(use 'retort.hiccup :reload)
(relevant-design {:h1 {:something :whatever}} [:div {:asdf 1} [:h1]] nil)
(use 'retort.core :reload)
(relevant-design {:h1 {:something :whatever}} [:div {:asdf 1} [:h1]] nil)
(use 'retort.core :reload)
(relevant-design {:h1 {:something :whatever}} [:div {:asdf 1} [:h1]] nil)
(use 'retort.core :reload)
(relevant-design {:h1 {:something :whatever}} [:div {:asdf 1} [:h1]] nil)
(brew {:asdf (fn [[_ & args]] (println "fjdlas") (into [:qwer] args))} [:asdf 1])
(brew {:asdf (fn [[_ & args]] (into [:qwer] args))} [:asdf 1])
(source inject)
(string/replace "asdf\nqwer" "\\n" #"\n")
(clojure.string/replace "asdf\nqwer" "\\n" #"\n")
(clojure.string/replace "asdf\nqwer" #"\n" "\\n")
(println (clojure.string/replace "asdf\nqwer" #"\n" "\\n"))
(println (clojure.string/replace "asdf\nqwer" #"\n" "\\\\n"))
(doc subvec)
clojure.lang.IDeref
