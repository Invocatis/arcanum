["^ ","~:output",["^ ","~:js","goog.provide('motif.core');\ngoog.require('cljs.core');\nmotif.core._ = (function motif$core$_(any){\n\nreturn true;\n});\nmotif.core.and_pattern = (function motif$core$and_pattern(p1,p2){\nreturn (function (target){\nvar and__4174__auto__ = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(target) : p1.call(null,target));\nif(cljs.core.truth_(and__4174__auto__)){\nreturn (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(target) : p2.call(null,target));\n} else {\nreturn and__4174__auto__;\n}\n});\n});\nmotif.core.strict_QMARK_ = (function motif$core$strict_QMARK_(pattern){\nreturn new cljs.core.Keyword(null,\"!\",\"!\",-311249637).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(pattern));\n});\nmotif.core.compile_meta = (function motif$core$compile_meta(pattern,accessor){\nreturn motif.core.and_pattern((function (){var G__25804 = cljs.core.with_meta(pattern,cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(cljs.core.meta(pattern),new cljs.core.Keyword(null,\"meta\",\"meta\",1499536964)));\nvar G__25805 = accessor;\nreturn (motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$2 ? motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$2(G__25804,G__25805) : motif.core.compile_pattern.call(null,G__25804,G__25805));\n})(),(function (){var G__25810 = new cljs.core.Keyword(null,\"meta\",\"meta\",1499536964).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(pattern));\nvar G__25811 = cljs.core.comp.cljs$core$IFn$_invoke$arity$2(cljs.core.meta,accessor);\nreturn (motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$2 ? motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$2(G__25810,G__25811) : motif.core.compile_pattern.call(null,G__25810,G__25811));\n})());\n});\nmotif.core.compile_star = (function motif$core$compile_star(pattern,accessor){\nvar map__25812 = cljs.core.meta(pattern);\nvar map__25812__$1 = (((((!((map__25812 == null))))?(((((map__25812.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__25812.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__25812):map__25812);\nvar star_value = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__25812__$1,new cljs.core.Keyword(null,\"*\",\"*\",-1294732318));\nvar meta = ((((typeof star_value === 'number') && ((star_value > (0)))))?cljs.core.update.cljs$core$IFn$_invoke$arity$3(cljs.core.meta(pattern),new cljs.core.Keyword(null,\"*\",\"*\",-1294732318),cljs.core.dec):cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(cljs.core.meta(pattern),new cljs.core.Keyword(null,\"*\",\"*\",-1294732318)));\nvar matcher = (function (){var G__25814 = cljs.core.with_meta(pattern,meta);\nreturn (motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$1 ? motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$1(G__25814) : motif.core.compile_pattern.call(null,G__25814));\n})();\nreturn (function (target){\nreturn cljs.core.every_QMARK_(matcher,(accessor.cljs$core$IFn$_invoke$arity$1 ? accessor.cljs$core$IFn$_invoke$arity$1(target) : accessor.call(null,target)));\n});\n});\nmotif.core.compile_use = (function motif$core$compile_use(pattern,accessor){\nreturn (function (target){\nvar G__25816 = pattern;\nvar G__25817 = (accessor.cljs$core$IFn$_invoke$arity$1 ? accessor.cljs$core$IFn$_invoke$arity$1(target) : accessor.call(null,target));\nvar fexpr__25815 = new cljs.core.Keyword(null,\"use\",\"use\",-1846382424).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(pattern));\nreturn (fexpr__25815.cljs$core$IFn$_invoke$arity$2 ? fexpr__25815.cljs$core$IFn$_invoke$arity$2(G__25816,G__25817) : fexpr__25815.call(null,G__25816,G__25817));\n});\n});\nmotif.core.compile_element = (function motif$core$compile_element(pattern,accessor){\nif(cljs.core.fn_QMARK_(pattern)){\nreturn (function (p1__25820_SHARP_){\nreturn cljs.core.boolean$((function (){var G__25826 = (accessor.cljs$core$IFn$_invoke$arity$1 ? accessor.cljs$core$IFn$_invoke$arity$1(p1__25820_SHARP_) : accessor.call(null,p1__25820_SHARP_));\nreturn (pattern.cljs$core$IFn$_invoke$arity$1 ? pattern.cljs$core$IFn$_invoke$arity$1(G__25826) : pattern.call(null,G__25826));\n})());\n});\n} else {\nreturn (function (p1__25821_SHARP_){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((accessor.cljs$core$IFn$_invoke$arity$1 ? accessor.cljs$core$IFn$_invoke$arity$1(p1__25821_SHARP_) : accessor.call(null,p1__25821_SHARP_)),pattern);\n});\n\n}\n});\nmotif.core.compile_simple_map = (function motif$core$compile_simple_map(pattern,accessor){\nvar getter = new cljs.core.Keyword(null,\"getter\",\"getter\",84844855).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(pattern));\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$2((cljs.core.truth_(new cljs.core.Keyword(null,\"|\",\"|\",-352411576).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(pattern)))?cljs.core.some_fn:cljs.core.every_pred),cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p__25837){\nvar vec__25841 = p__25837;\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__25841,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__25841,(1),null);\nvar acc = (function (){var or__4185__auto__ = (cljs.core.truth_(getter)?(function (p1__25828_SHARP_){\nreturn (getter.cljs$core$IFn$_invoke$arity$2 ? getter.cljs$core$IFn$_invoke$arity$2(p1__25828_SHARP_,k) : getter.call(null,p1__25828_SHARP_,k));\n}):null);\nif(cljs.core.truth_(or__4185__auto__)){\nreturn or__4185__auto__;\n} else {\nif(cljs.core.ifn_QMARK_(k)){\nreturn k;\n} else {\nreturn (function (p1__25830_SHARP_){\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(p1__25830_SHARP_,k);\n});\n}\n}\n})();\nvar G__25846 = v;\nvar G__25847 = cljs.core.comp.cljs$core$IFn$_invoke$arity$2(acc,accessor);\nreturn (motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$2 ? motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$2(G__25846,G__25847) : motif.core.compile_pattern.call(null,G__25846,G__25847));\n}),pattern));\n});\nmotif.core.compile_map = (function motif$core$compile_map(pattern,accessor){\nif(cljs.core.empty_QMARK_(pattern)){\nif(cljs.core.truth_(motif.core.strict_QMARK_(pattern))){\nreturn (function (target){\nreturn cljs.core.empty_QMARK_((accessor.cljs$core$IFn$_invoke$arity$1 ? accessor.cljs$core$IFn$_invoke$arity$1(target) : accessor.call(null,target)));\n});\n} else {\nreturn (function (target){\nreturn true;\n});\n}\n} else {\nif(cljs.core.truth_(motif.core.strict_QMARK_(pattern))){\nreturn motif.core.and_pattern(motif.core.compile_simple_map(pattern,accessor),(function (target){\nreturn cljs.core.every_QMARK_(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(cljs.core.contains_QMARK_,pattern),cljs.core.keys((accessor.cljs$core$IFn$_invoke$arity$1 ? accessor.cljs$core$IFn$_invoke$arity$1(target) : accessor.call(null,target))));\n}));\n} else {\nreturn motif.core.compile_simple_map(pattern,accessor);\n}\n}\n});\nmotif.core.compile_simple_vector = (function motif$core$compile_simple_vector(pattern,accessor){\nvar subpatterns = cljs.core.map_indexed.cljs$core$IFn$_invoke$arity$2((function (i,p){\nvar G__25850 = p;\nvar G__25851 = cljs.core.comp.cljs$core$IFn$_invoke$arity$2((function (p1__25848_SHARP_){\nreturn cljs.core.nth.cljs$core$IFn$_invoke$arity$2(p1__25848_SHARP_,i);\n}),accessor);\nreturn (motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$2 ? motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$2(G__25850,G__25851) : motif.core.compile_pattern.call(null,G__25850,G__25851));\n}),pattern);\nreturn (function (target){\nmotif.core.sp = subpatterns;\n\nreturn (((cljs.core.count(pattern) <= cljs.core.count((accessor.cljs$core$IFn$_invoke$arity$1 ? accessor.cljs$core$IFn$_invoke$arity$1(target) : accessor.call(null,target))))) && (cljs.core.every_QMARK_((function (p1__25849_SHARP_){\nreturn (p1__25849_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__25849_SHARP_.cljs$core$IFn$_invoke$arity$1(target) : p1__25849_SHARP_.call(null,target));\n}),subpatterns)));\n});\n});\nmotif.core.compile_vector = (function motif$core$compile_vector(pattern,accessor){\nif(cljs.core.truth_(motif.core.strict_QMARK_(pattern))){\nreturn motif.core.and_pattern((function (target){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(pattern),cljs.core.count((accessor.cljs$core$IFn$_invoke$arity$1 ? accessor.cljs$core$IFn$_invoke$arity$1(target) : accessor.call(null,target))));\n}),motif.core.compile_simple_vector(pattern,accessor));\n} else {\nreturn motif.core.compile_simple_vector(pattern,accessor);\n}\n});\nmotif.core.compile_seq = (function motif$core$compile_seq(pattern,accessor){\nreturn (function (value){\nvar n = cljs.core.count((accessor.cljs$core$IFn$_invoke$arity$1 ? accessor.cljs$core$IFn$_invoke$arity$1(value) : accessor.call(null,value)));\nreturn cljs.core.every_QMARK_(cljs.core.boolean$,cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__25854_SHARP_){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(p1__25854_SHARP_,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [value], null));\n}),cljs.core.take.cljs$core$IFn$_invoke$arity$2(n,cljs.core.map_indexed.cljs$core$IFn$_invoke$arity$2((function (i,p){\nvar G__25856 = p;\nvar G__25857 = cljs.core.comp.cljs$core$IFn$_invoke$arity$2((function (p1__25855_SHARP_){\nreturn cljs.core.nth.cljs$core$IFn$_invoke$arity$3(p1__25855_SHARP_,i,null);\n}),accessor);\nreturn (motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$2 ? motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$2(G__25856,G__25857) : motif.core.compile_pattern.call(null,G__25856,G__25857));\n}),pattern))));\n});\n});\nmotif.core.compile_set = (function motif$core$compile_set(pattern,accessor){\nvar subpatterns = cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__25858_SHARP_){\nreturn (motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$2 ? motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$2(p1__25858_SHARP_,accessor) : motif.core.compile_pattern.call(null,p1__25858_SHARP_,accessor));\n}),pattern);\nif(cljs.core.truth_(motif.core.strict_QMARK_(pattern))){\nreturn (function (target){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((1),cljs.core.count(cljs.core.filter.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (sp){\nreturn (sp.cljs$core$IFn$_invoke$arity$1 ? sp.cljs$core$IFn$_invoke$arity$1(target) : sp.call(null,target));\n}),subpatterns))));\n});\n} else {\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"&\",\"&\",509580121).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(pattern)))){\nreturn (function (target){\nreturn cljs.core.every_QMARK_(cljs.core.identity,cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (sp){\nreturn (sp.cljs$core$IFn$_invoke$arity$1 ? sp.cljs$core$IFn$_invoke$arity$1(target) : sp.call(null,target));\n}),subpatterns));\n});\n} else {\nreturn (function (target){\nreturn (!(cljs.core.empty_QMARK_(cljs.core.filter.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (sp){\nreturn (sp.cljs$core$IFn$_invoke$arity$1 ? sp.cljs$core$IFn$_invoke$arity$1(target) : sp.call(null,target));\n}),subpatterns)))));\n});\n\n}\n}\n});\nmotif.core.compile_regex = (function motif$core$compile_regex(pattern,accessor){\nreturn (function (value){\nreturn cljs.core.boolean$(cljs.core.re_matches(pattern,cljs.core.str.cljs$core$IFn$_invoke$arity$1((accessor.cljs$core$IFn$_invoke$arity$1 ? accessor.cljs$core$IFn$_invoke$arity$1(value) : accessor.call(null,value)))));\n});\n});\nmotif.core.regex_type = cljs.core.type((new RegExp(\"\")));\nmotif.core.regex_QMARK_ = (function motif$core$regex_QMARK_(any){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.type(any),motif.core.regex_type);\n});\nmotif.core.compile_pattern = (function motif$core$compile_pattern(var_args){\nvar G__25860 = arguments.length;\nswitch (G__25860) {\ncase 1:\nreturn motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$1 = (function (pattern){\nreturn motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$2(pattern,cljs.core.identity);\n}));\n\n(motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$2 = (function (pattern,accessor){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"*\",\"*\",-1294732318).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(pattern)))){\nreturn motif.core.compile_star(pattern,accessor);\n} else {\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"meta\",\"meta\",1499536964).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(pattern)))){\nreturn motif.core.compile_meta(pattern,accessor);\n} else {\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"=\",\"=\",1152933628).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(pattern)))){\nreturn motif.core.compile_use(cljs.core.with_meta(pattern,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.meta(pattern),new cljs.core.Keyword(null,\"use\",\"use\",-1846382424),cljs.core._EQ_)),accessor);\n} else {\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"use\",\"use\",-1846382424).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(pattern)))){\nreturn motif.core.compile_use(pattern,accessor);\n} else {\nif(cljs.core.map_QMARK_(pattern)){\nreturn motif.core.compile_map(pattern,accessor);\n} else {\nif(cljs.core.set_QMARK_(pattern)){\nreturn motif.core.compile_set(pattern,accessor);\n} else {\nif(cljs.core.vector_QMARK_(pattern)){\nreturn motif.core.compile_vector(pattern,accessor);\n} else {\nif(cljs.core.seq_QMARK_(pattern)){\nreturn motif.core.compile_seq(pattern,accessor);\n} else {\nif(motif.core.regex_QMARK_(pattern)){\nreturn motif.core.compile_regex(pattern,accessor);\n} else {\nreturn motif.core.compile_element(pattern,accessor);\n\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}));\n\n(motif.core.compile_pattern.cljs$lang$maxFixedArity = 2);\n\n/**\n * Given a pattern, and an expression, recursively determines\n *   if the expression matches the pattern.\n * \n *   For f, a function, and x, any expression:\n * \n *  (match f e) => (f e)\n * \n *   For vector patterns, each ordinal spot is checked:\n * \n *  (matches? [p0 p1 p2] [t0 t1 t2]) =>\n *      [t0 t1 t2 ...]\n *        ↑  ↑  ↑      matches?\n *      [p0 p1 p2 ...]\n * \n *  Vectors ensure their targets are at least as long as they are.\n *  Strict vectors must have identical lengths.\n * \n *   For lazy sequence patterns, like vectors, each oridnal spot is checked:\n * \n *  (matches? (p0 p1 p2) (t0 t1 t2)) =>\n *      (t0 t1 t2 ...)\n *        ↑  ↑  ↑      matches?\n *      (p0 p1 p2 ...)\n * \n *  Lazy seqs targets can be shorter, or longer, than they are.\n *  Infinite sequences can be used, though if they are matched against\n *  inifinte targets, a infinte loop will happen\n * \n *   For m, a map with keyset {k1,k2,...,kn}, and n, a map:\n * \n *  (match m n) => (and (match (get m k1) (get n k1))\n *                      (match (get m k2) (get n k2))\n *                      ...\n * \n *  If the key is an ifn, it will be applied to the target instead.\n *  Strict maps require that the pattern contains all keys of the target.\n * \n *   Set patterns are disjunctive, and only require one of their elements to match.\n * \n *  (match m n) => (or (match m0 n)\n *                     (match m1 n)\n *                     ...\n * \n *  Strict set patterns require exactly one element to match.\n * \n *   For any pattern not described above, equality is checked.\n * \n *  (match 1 2) => (= 1 2)\n * \n *   Given the expression passed matches the given pattern,\n *   true will be returned. Otherwise, false will be returned.\n * \n * \n *   Meta tag modifers can enhance and change how each pattern functions.\n * \n *  ^:!\n *    Strict modifier is defined for each pattern type\n *  ^:=\n *    Equality modifier forces equality to be used, rather than matches?\n *  {^:use f}\n *    Use mofider forces f to be used as predicate, rather than matches?\n *  ^:*\n *    Star modifier maps pattern over target, expecting all to match\n *  {^:meta m}\n *    Meta modifier matches m to the meta of the target\n *   \n */\nmotif.core.matches_QMARK_ = (function motif$core$matches_QMARK_(var_args){\nvar G__25862 = arguments.length;\nswitch (G__25862) {\ncase 1:\nreturn motif.core.matches_QMARK_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn motif.core.matches_QMARK_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(motif.core.matches_QMARK_.cljs$core$IFn$_invoke$arity$1 = (function (pattern){\nreturn (function (target){\ntry{return cljs.core.apply.cljs$core$IFn$_invoke$arity$2(motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$1(pattern),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [target], null));\n}catch (e25863){var _ = e25863;\nreturn false;\n}});\n}));\n\n(motif.core.matches_QMARK_.cljs$core$IFn$_invoke$arity$2 = (function (pattern,expr){\ntry{return cljs.core.apply.cljs$core$IFn$_invoke$arity$2(motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$1(pattern),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [expr], null));\n}catch (e25864){var _ = e25864;\nreturn false;\n}}));\n\n(motif.core.matches_QMARK_.cljs$lang$maxFixedArity = 2);\n\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","motif/core.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",15],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$create-react-class","~$module$node_modules$create_react_class$index","~$react-dom","~$module$node_modules$react_dom$index"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$motif.core","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$cljs.core","^M","~$goog","^N"],"~:seen",["^F",[]],"~:uses",null,"~:require-macros",["^ ","^M","^M"],"~:form",["~#list",["~$ns","^H"]],"~:flags",["^ "],"~:js-deps",["^ "],"~:deps",["^N","^M"]],"^J","^H","~:resource-id",["~:shadow.build.classpath/resource","motif/core.cljc"],"~:compiled-at",1580167379801,"~:resource-name","motif/core.cljc","~:warnings",[],"~:source","(ns motif.core)\n\n(declare compile-pattern)\n\n(defn _\n  [any]\n  \"Any predicate, returns true on all inputs\"\n  true)\n\n(defn- and-pattern\n  [p1 p2]\n  (fn [target] (and (p1 target) (p2 target))))\n\n(defn- strict?\n  [pattern]\n  (-> pattern meta :!))\n\n(defn- compile-meta\n  [pattern accessor]\n  (and-pattern\n    (compile-pattern (with-meta pattern (dissoc (meta pattern) :meta)) accessor)\n    (compile-pattern (:meta (meta pattern)) (comp meta accessor))))\n\n(defn- compile-star\n  [pattern accessor]\n  (let [{star-value :*} (meta pattern)\n        meta (if (and (number? star-value) (> star-value 0))\n               (update (meta pattern) :* dec)\n               (dissoc (meta pattern) :*))\n        matcher (compile-pattern (with-meta pattern meta))]\n    (fn [target] (every? matcher (accessor target)))))\n\n(defn- compile-use\n  [pattern accessor]\n  (fn [target] ((:use (meta pattern)) pattern (accessor target))))\n\n(defn- compile-element\n  [pattern accessor]\n  (cond\n    (fn? pattern) #(boolean (pattern (accessor %)))\n    :else #(= (accessor %) pattern)))\n\n(defn- compile-simple-map\n  [pattern accessor]\n  (let [getter (-> pattern meta :getter)]\n    (reduce\n      (if (-> pattern meta :|)\n        some-fn\n        every-pred)\n      (map\n        (fn [[k v]]\n          (let [acc (or (when getter #(getter % k)) (if (ifn? k) k #(get % k)))]\n            (compile-pattern v\n              (comp acc accessor))))\n        pattern))))\n\n(defn- compile-map\n  [pattern accessor]\n  (if (empty? pattern)\n    (if (strict? pattern)\n      (fn [target] (empty? (accessor target)))\n      (fn [target] true))\n    (if (strict? pattern)\n      (and-pattern\n        (compile-simple-map pattern accessor)\n        (fn [target] (every? (partial contains? pattern) (keys (accessor target)))))\n      (compile-simple-map pattern accessor))))\n\n(defn- compile-simple-vector\n  [pattern accessor]\n  (let [subpatterns (map-indexed\n                      (fn [i p] (compile-pattern p (comp #(nth % i) accessor)))\n                      pattern)]\n    (fn [target]\n      (def sp subpatterns)\n      (and\n        (<= (count pattern) (count (accessor target)))\n        (every? #(% target) subpatterns)))))\n\n(defn- compile-vector\n  [pattern accessor]\n  (if (strict? pattern)\n    (and-pattern\n      (fn [target] (= (count pattern) (count (accessor target))))\n      (compile-simple-vector pattern accessor))\n    (compile-simple-vector pattern accessor)))\n\n(defn- compile-seq\n  [pattern accessor]\n  (fn [value]\n    (let [n (count (accessor value))]\n      (every?\n        boolean\n        (map\n          #(apply % [value])\n          (take n\n            (map-indexed\n              (fn [i p]\n                (compile-pattern p\n                  (comp #(nth % i nil) accessor)))\n              pattern)))))))\n\n(defn- compile-set\n  [pattern accessor]\n  (let [subpatterns (map #(compile-pattern % accessor) pattern)]\n    (cond\n      (strict? pattern)\n      (fn [target]\n        (= 1 (count (filter identity (map (fn [sp] (sp target)) subpatterns)))))\n      (-> pattern meta :&)\n      (fn [target]\n        (every? identity (map (fn [sp] (sp target)) subpatterns)))\n      :else\n      (fn [target]\n        (not (empty? (filter identity (map (fn [sp] (sp target)) subpatterns))))))))\n\n(defn- compile-regex\n  [pattern accessor]\n  (fn [value]\n    (boolean (re-matches pattern (-> value accessor str)))))\n\n(def ^:private regex-type (type #\"\"))\n\n(defn- regex?\n  [any]\n  (= (type any) regex-type))\n\n(defn compile-pattern\n  ([pattern]\n   (compile-pattern pattern identity))\n  ([pattern accessor]\n   (cond\n     (-> pattern meta :*)\n     (compile-star pattern accessor)\n\n     (-> pattern meta :meta)\n     (compile-meta pattern accessor)\n\n     (-> pattern meta :=)\n     (compile-use (with-meta pattern (assoc (meta pattern) :use =)) accessor)\n\n     (-> pattern meta :use)\n     (compile-use pattern accessor)\n\n     (map? pattern)\n     (compile-map pattern accessor)\n\n     (set? pattern)\n     (compile-set pattern accessor)\n\n     (vector? pattern) (compile-vector pattern accessor)\n\n     (seq? pattern) (compile-seq pattern accessor)\n\n     (regex? pattern) (compile-regex pattern accessor)\n\n     :else (compile-element pattern accessor))))\n\n(defn matches?\n  \"Given a pattern, and an expression, recursively determines\n  if the expression matches the pattern.\n\n  For f, a function, and x, any expression:\n\n    (match f e) => (f e)\n\n  For vector patterns, each ordinal spot is checked:\n\n    (matches? [p0 p1 p2] [t0 t1 t2]) =>\n        [t0 t1 t2 ...]\n          ↑  ↑  ↑      matches?\n        [p0 p1 p2 ...]\n\n    Vectors ensure their targets are at least as long as they are.\n    Strict vectors must have identical lengths.\n\n  For lazy sequence patterns, like vectors, each oridnal spot is checked:\n\n    (matches? (p0 p1 p2) (t0 t1 t2)) =>\n        (t0 t1 t2 ...)\n          ↑  ↑  ↑      matches?\n        (p0 p1 p2 ...)\n\n    Lazy seqs targets can be shorter, or longer, than they are.\n    Infinite sequences can be used, though if they are matched against\n    inifinte targets, a infinte loop will happen\n\n  For m, a map with keyset {k1,k2,...,kn}, and n, a map:\n\n    (match m n) => (and (match (get m k1) (get n k1))\n                        (match (get m k2) (get n k2))\n                        ...\n\n    If the key is an ifn, it will be applied to the target instead.\n    Strict maps require that the pattern contains all keys of the target.\n\n  Set patterns are disjunctive, and only require one of their elements to match.\n\n    (match m n) => (or (match m0 n)\n                       (match m1 n)\n                       ...\n\n    Strict set patterns require exactly one element to match.\n\n  For any pattern not described above, equality is checked.\n\n    (match 1 2) => (= 1 2)\n\n  Given the expression passed matches the given pattern,\n  true will be returned. Otherwise, false will be returned.\n\n\n  Meta tag modifers can enhance and change how each pattern functions.\n\n    ^:!\n      Strict modifier is defined for each pattern type\n    ^:=\n      Equality modifier forces equality to be used, rather than matches?\n    {^:use f}\n      Use mofider forces f to be used as predicate, rather than matches?\n    ^:*\n      Star modifier maps pattern over target, expecting all to match\n    {^:meta m}\n      Meta modifier matches m to the meta of the target\n  \"\n  ([pattern]\n   (fn [target]\n     (try\n       (apply (compile-pattern pattern) [target])\n       (catch #?(:clj Exception :cljs :default) _ false))))\n  ([pattern expr]\n   (try\n     (apply (compile-pattern pattern) [expr])\n     (catch #?(:clj Exception :cljs :default) _ false))))\n\n(defmacro match\n  \"Takes a subject expression, and a set of clauses.\n  Each clause should be of the form:\n\n    pattern resultant\n\n  For each clause, (match pattern expr) is performed. If it\n  returns logical true, the clause is a match and the resultant\n  is returned. A single default expression can follow the clauses\n  and its value will be returned if no clause matches. If no\n  default expression is provided, and no clause matches, nil will\n  be returned\"\n  ([expr]\n   nil)\n  ([expr default]\n   `~default)\n  ([expr pattern result & statements]\n   `(if (matches? ~pattern ~expr)\n      ~result\n      ~(cons `match (cons expr statements)))))\n","~:reader-features",["^F",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["motif.core/_","any","motif.core/and-pattern","p1","p2","target","and__4174__auto__","motif.core/strict?","pattern","cljs.core/meta","motif.core/compile-meta","accessor","G__25804","G__25805","motif.core/compile-pattern","cljs.core/with-meta","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","G__25810","G__25811","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","motif.core/compile-star","map__25812","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","star-value","meta","cljs.core.update.cljs$core$IFn$_invoke$arity$3","cljs.core/dec","matcher","G__25814","cljs.core/every?","motif.core/compile-use","G__25816","G__25817","fexpr__25815","motif.core/compile-element","p1__25820#","p1__25821#","cljs.core/fn?","cljs.core/boolean","G__25826","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","motif.core/compile-simple-map","getter","cljs.core.reduce.cljs$core$IFn$_invoke$arity$2","cljs.core/some-fn","cljs.core/every-pred","cljs.core.map.cljs$core$IFn$_invoke$arity$2","p__25837","vec__25841","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","k","v","acc","or__4185__auto__","p1__25828#","p1__25830#","cljs.core/ifn?","G__25846","G__25847","motif.core/compile-map","cljs.core/empty?","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","cljs.core/contains?","cljs.core/keys","motif.core/compile-simple-vector","subpatterns","cljs.core.map_indexed.cljs$core$IFn$_invoke$arity$2","i","p","G__25850","G__25851","p1__25848#","cljs.core.nth.cljs$core$IFn$_invoke$arity$2","motif.core/sp","cljs.core/count","p1__25849#","motif.core/compile-vector","motif.core/compile-seq","value","n","p1__25854#","cljs.core.take.cljs$core$IFn$_invoke$arity$2","G__25856","G__25857","p1__25855#","motif.core/compile-set","p1__25858#","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core/identity","sp","motif.core/compile-regex","cljs.core/re-matches","motif.core/regex-type","cljs.core/type","motif.core/regex?","var_args","G__25860","js/Error","motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$2","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","cljs.core/=","cljs.core/map?","cljs.core/set?","cljs.core/vector?","cljs.core/seq?","G__25862","motif.core/matches?","e25863","motif.core.compile_pattern.cljs$core$IFn$_invoke$arity$1","_","expr","e25864"]]],"~:cache-keys",["~#cmap",[["^Y","goog/dom/tagname.js"],[1575310859000,"~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^F",[]],"~:deps-syms",["^N","~$goog.dom.HtmlElement"]]],["^Y","goog/math/math.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","~$goog.array","~$goog.asserts"]]],["^Y","goog/html/trustedtypes.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N"]]],["^Y","goog/labs/useragent/browser.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1?","~$goog.labs.userAgent.util","~$goog.object","~$goog.string.internal"]]],["^Y","goog/html/safeurl.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1@","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^1C"]]],["^Y","goog/array/array.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1@"]]],["^Y","motif/core.cljc"],[1580167243000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^M"]]],["^Y","goog/debug/error.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N"]]],["^Y","goog/dom/nodetype.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N"]]],["^Y","goog/string/typedstring.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N"]]],["^Y","goog/object/object.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N"]]],["^Y","goog/dom/asserts.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1@"]]],"~:SHADOW-TIMESTAMP",[1575415273000,1575310856000],["^Y","goog/math/long.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1@","~$goog.reflect"]]],["^Y","goog/html/trustedresourceurl.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1@","~$goog.html.trustedtypes","^1F","^1G","^1H","^1I"]]],["^Y","goog/string/internal.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N"]]],["^Y","goog/functions/functions.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N"]]],["^Y","goog/html/safestyle.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1?","^1@","~$goog.html.SafeUrl","^1H","^1I","^1C"]]],["^Y","goog/dom/safe.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1@","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","~$goog.html.SafeScript","~$goog.html.SafeStyle","^1M","^1E","~$goog.html.uncheckedconversions","^1H","^1C"]]],["^Y","goog/structs/map.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^Y","goog/html/safehtml.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1?","^1@","~$goog.dom.TagName","~$goog.dom.tags","^1Q","^1R","~$goog.html.SafeStyleSheet","^1M","^1E","^1L","^1F","^1G","~$goog.labs.userAgent.browser","^1B","^1H","^1I","^1C"]]],["^Y","goog/dom/tags.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1B"]]],["^Y","goog/asserts/asserts.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^Y","goog/uri/uri.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1?","^1@","~$goog.string","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^Y","goog/i18n/bidi.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N"]]],["^Y","goog/fs/url.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N"]]],["^Y","goog/base.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",[]]],["^Y","goog/structs/structs.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1?","^1B"]]],["^Y","goog/string/string.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","~$goog.dom.safe","^1S","^1H","^1C"]]],["^Y","goog/reflect/reflect.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N"]]],["^Y","goog/labs/useragent/util.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1C"]]],["^Y","goog/string/stringbuffer.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N"]]],["^Y","goog/iter/iter.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1?","^1@","^1O","~$goog.math"]]],["^Y","goog/html/uncheckedconversions.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1@","^1P","^1Q","^1R","^1X","^1M","^1E","^1H","^1C"]]],["^Y","goog/dom/htmlelement.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N"]]],["^Y","cljs/core.cljs"],[1575310856000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["~$goog.math.Long","~$goog.math.Integer","^20","^1B","^1?","~$goog.Uri","~$goog.string.StringBuffer"]]],["^Y","goog/html/safescript.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1@","^1L","^1H","^1I"]]],["^Y","goog/html/safestylesheet.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1?","^1@","^1R","^1B","^1H","^1I","^1C"]]],["^Y","goog/math/integer.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1K"]]],["^Y","goog/uri/utils.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1?","^1@","^20"]]],["^Y","goog/string/const.js"],[1575310859000,"^1:",["^ ","^1;",null,"^1<",["^F",[]],"^1=",["^N","^1@","^1I"]]]]],"~:clj-info",["^ ","jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/string.clj",1575308778000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/data.json/0.2.6/data.json-0.2.6.jar!/clojure/data/json.clj",1567798415000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/pprint.clj",1575308778000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/util.cljc",1575310856000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/impl/errors.clj",1569088367000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/compiler.cljc",1575310856000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/js_deps.cljc",1575310856000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/impl/inspect.clj",1569088367000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/instant.clj",1575308778000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/analyzer.cljc",1575310856000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/java/io.clj",1575308778000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/set.clj",1575308778000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/source_map/base64_vlq.clj",1575310856000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/core.clj",1575308778000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/default_data_readers.clj",1569088367000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/source_map/base64.clj",1575310856000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/core.cljc",1575310856000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/reader_types.clj",1569088367000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/tagged_literals.cljc",1575310856000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/externs.clj",1575310856000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader.clj",1569088367000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/env.cljc",1575310856000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/clojurescript/1.10.597/clojurescript-1.10.597.jar!/cljs/source_map.clj",1575310856000,"jar:file:/Users/ljc237-admin/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/edn.clj",1575308778000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","motif/core.cljc","^7",1,"^8",5,"^9",1,"^:",15],"^;",["^ ","^<","^=","^>","^?","^@","^A","^B","^C"],"^D",null,"^E",["^F",[]],"^G","^H","^K",null,"^L",["^ ","^M","^M","^N","^N"],"^O",["^F",[]],"~:shadow/js-access-global",["^F",["Error"]],"^P",null,"~:defs",["^ ","~$compile-vector",["^ ","~:protocol-inline",null,"^5",["^ ","^6","motif/core.cljc","^7",80,"^8",8,"^9",80,"^:",22,"~:private",true,"~:arglists",["^S",["~$quote",["^S",[["~$pattern","~$accessor"]]]]]],"^2Z",true,"^G","~$motif.core/compile-vector","^6","motif/core.cljc","^:",22,"~:method-params",["^S",[["^31","^32"]]],"~:protocol-impl",null,"~:arglists-meta",["^S",[null,null]],"^8",1,"~:variadic?",false,"^7",80,"~:ret-tag","~$function","^9",80,"~:max-fixed-arity",2,"~:fn-var",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"~$compile-seq",["^ ","^2Y",null,"^5",["^ ","^6","motif/core.cljc","^7",88,"^8",8,"^9",88,"^:",19,"^2Z",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"^2Z",true,"^G","~$motif.core/compile-seq","^6","motif/core.cljc","^:",19,"^34",["^S",[["^31","^32"]]],"^35",null,"^36",["^S",[null,null]],"^8",1,"^37",false,"^7",88,"^38","^39","^9",88,"^3:",2,"^3;",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"~$compile-simple-vector",["^ ","^2Y",null,"^5",["^ ","^6","motif/core.cljc","^7",69,"^8",8,"^9",69,"^:",29,"^2Z",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"^2Z",true,"^G","~$motif.core/compile-simple-vector","^6","motif/core.cljc","^:",29,"^34",["^S",[["^31","^32"]]],"^35",null,"^36",["^S",[null,null]],"^8",1,"^37",false,"^7",69,"^38","^39","^9",69,"^3:",2,"^3;",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"~$compile-simple-map",["^ ","^2Y",null,"^5",["^ ","^6","motif/core.cljc","^7",43,"^8",8,"^9",43,"^:",26,"^2Z",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"^2Z",true,"^G","~$motif.core/compile-simple-map","^6","motif/core.cljc","^:",26,"^34",["^S",[["^31","^32"]]],"^35",null,"^36",["^S",[null,null]],"^8",1,"^37",false,"^7",43,"^38","~$any","^9",43,"^3:",2,"^3;",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"~$compile-pattern",["^ ","^2Y",null,"^5",["^ ","^6","motif/core.cljc","^7",128,"^8",7,"^9",128,"^:",22,"^2[",["^S",["^30",["^S",[["^31"],["^31","^32"]]]]],"~:top-fn",["^ ","^37",false,"~:fixed-arity",2,"^3:",2,"^34",["^S",[["^31"],["^31","^32"]]],"^2[",["^S",[["^31"],["^31","^32"]]],"^36",["^S",[null,null]]]],"^G","~$motif.core/compile-pattern","^6","motif/core.cljc","^:",22,"^3D",["^ ","^37",false,"^3E",2,"^3:",2,"^34",["^S",[["^31"],["^31","^32"]]],"^2[",["^S",[["^31"],["^31","^32"]]],"^36",["^S",[null,null]]],"^34",["^S",[["^31"],["^31","^32"]]],"^35",null,"^3E",2,"^36",["^S",[null,null]],"^8",1,"^37",false,"~:methods",[["^ ","^3E",1,"^37",false,"~:tag","^3B"],["^ ","^3E",2,"^37",false,"^3H",["^F",["^3B","^39"]]]],"^7",128,"^9",128,"^3:",2,"^3;",true,"^2[",["^S",[["^31"],["^31","^32"]]]],"~$compile-map",["^ ","^2Y",null,"^5",["^ ","^6","motif/core.cljc","^7",57,"^8",8,"^9",57,"^:",19,"^2Z",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"^2Z",true,"^G","~$motif.core/compile-map","^6","motif/core.cljc","^:",19,"^34",["^S",[["^31","^32"]]],"^35",null,"^36",["^S",[null,null]],"^8",1,"^37",false,"^7",57,"^38",["^F",["^3B","^39"]],"^9",57,"^3:",2,"^3;",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"~$compile-element",["^ ","^2Y",null,"^5",["^ ","^6","motif/core.cljc","^7",37,"^8",8,"^9",37,"^:",23,"^2Z",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"^2Z",true,"^G","~$motif.core/compile-element","^6","motif/core.cljc","^:",23,"^34",["^S",[["^31","^32"]]],"^35",null,"^36",["^S",[null,null]],"^8",1,"^37",false,"^7",37,"^38","^39","^9",37,"^3:",2,"^3;",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"~$and-pattern",["^ ","^2Y",null,"^5",["^ ","^6","motif/core.cljc","^7",10,"^8",8,"^9",10,"^:",19,"^2Z",true,"^2[",["^S",["^30",["^S",[["~$p1","~$p2"]]]]]],"^2Z",true,"^G","~$motif.core/and-pattern","^6","motif/core.cljc","^:",19,"^34",["^S",[["^3N","^3O"]]],"^35",null,"^36",["^S",[null,null]],"^8",1,"^37",false,"^7",10,"^38","^39","^9",10,"^3:",2,"^3;",true,"^2[",["^S",["^30",["^S",[["^3N","^3O"]]]]]],"~$strict?",["^ ","^2Y",null,"^5",["^ ","^6","motif/core.cljc","^7",14,"^8",8,"^9",14,"^:",15,"^2Z",true,"^2[",["^S",["^30",["^S",[["^31"]]]]]],"^2Z",true,"^G","~$motif.core/strict?","^6","motif/core.cljc","^:",15,"^34",["^S",[["^31"]]],"^35",null,"^36",["^S",[null,null]],"^8",1,"^37",false,"^7",14,"^38","^3B","^9",14,"^3:",1,"^3;",true,"^2[",["^S",["^30",["^S",[["^31"]]]]]],"~$sp",["^ ","^G","~$motif.core/sp","^6","motif/core.cljc","^7",75,"^8",7,"^9",75,"^:",14,"^5",["^ ","^6","motif/core.cljc","^7",75,"^8",12,"^9",75,"^:",14],"^3H","^3B"],"~$_",["^ ","^2Y",null,"^5",["^ ","^6","motif/core.cljc","^7",5,"^8",7,"^9",5,"^:",8,"^2[",["^S",["^30",["^S",[["^3B"]]]]]],"^G","~$motif.core/_","^6","motif/core.cljc","^:",8,"^34",["^S",[["^3B"]]],"^35",null,"^36",["^S",[null,null]],"^8",1,"^37",false,"^7",5,"^38","~$boolean","^9",5,"^3:",1,"^3;",true,"^2[",["^S",["^30",["^S",[["^3B"]]]]]],"~$regex?",["^ ","^2Y",null,"^5",["^ ","^6","motif/core.cljc","^7",124,"^8",8,"^9",124,"^:",14,"^2Z",true,"^2[",["^S",["^30",["^S",[["^3B"]]]]]],"^2Z",true,"^G","~$motif.core/regex?","^6","motif/core.cljc","^:",14,"^34",["^S",[["^3B"]]],"^35",null,"^36",["^S",[null,null]],"^8",1,"^37",false,"^7",124,"^38","^3V","^9",124,"^3:",1,"^3;",true,"^2[",["^S",["^30",["^S",[["^3B"]]]]]],"~$compile-regex",["^ ","^2Y",null,"^5",["^ ","^6","motif/core.cljc","^7",117,"^8",8,"^9",117,"^:",21,"^2Z",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"^2Z",true,"^G","~$motif.core/compile-regex","^6","motif/core.cljc","^:",21,"^34",["^S",[["^31","^32"]]],"^35",null,"^36",["^S",[null,null]],"^8",1,"^37",false,"^7",117,"^38","^39","^9",117,"^3:",2,"^3;",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"~$regex-type",["^ ","^5",["^ ","^6","motif/core.cljc","^7",122,"^8",16,"^9",122,"^:",26,"^2Z",true],"^2Z",true,"^G","~$motif.core/regex-type","^6","motif/core.cljc","^:",26,"^8",1,"^7",122,"^9",122,"^3H",["^F",["^3B","~$clj-nil"]]],"~$compile-meta",["^ ","^2Y",null,"^5",["^ ","^6","motif/core.cljc","^7",18,"^8",8,"^9",18,"^:",20,"^2Z",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"^2Z",true,"^G","~$motif.core/compile-meta","^6","motif/core.cljc","^:",20,"^34",["^S",[["^31","^32"]]],"^35",null,"^36",["^S",[null,null]],"^8",1,"^37",false,"^7",18,"^38","^39","^9",18,"^3:",2,"^3;",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"~$matches?",["^ ","^2Y",null,"^5",["^ ","^6","motif/core.cljc","^7",159,"^8",7,"^9",159,"^:",15,"^2[",["^S",["^30",["^S",[["^31"],["^31","~$expr"]]]]],"~:doc","Given a pattern, and an expression, recursively determines\n  if the expression matches the pattern.\n\n  For f, a function, and x, any expression:\n\n    (match f e) => (f e)\n\n  For vector patterns, each ordinal spot is checked:\n\n    (matches? [p0 p1 p2] [t0 t1 t2]) =>\n        [t0 t1 t2 ...]\n          ↑  ↑  ↑      matches?\n        [p0 p1 p2 ...]\n\n    Vectors ensure their targets are at least as long as they are.\n    Strict vectors must have identical lengths.\n\n  For lazy sequence patterns, like vectors, each oridnal spot is checked:\n\n    (matches? (p0 p1 p2) (t0 t1 t2)) =>\n        (t0 t1 t2 ...)\n          ↑  ↑  ↑      matches?\n        (p0 p1 p2 ...)\n\n    Lazy seqs targets can be shorter, or longer, than they are.\n    Infinite sequences can be used, though if they are matched against\n    inifinte targets, a infinte loop will happen\n\n  For m, a map with keyset {k1,k2,...,kn}, and n, a map:\n\n    (match m n) => (and (match (get m k1) (get n k1))\n                        (match (get m k2) (get n k2))\n                        ...\n\n    If the key is an ifn, it will be applied to the target instead.\n    Strict maps require that the pattern contains all keys of the target.\n\n  Set patterns are disjunctive, and only require one of their elements to match.\n\n    (match m n) => (or (match m0 n)\n                       (match m1 n)\n                       ...\n\n    Strict set patterns require exactly one element to match.\n\n  For any pattern not described above, equality is checked.\n\n    (match 1 2) => (= 1 2)\n\n  Given the expression passed matches the given pattern,\n  true will be returned. Otherwise, false will be returned.\n\n\n  Meta tag modifers can enhance and change how each pattern functions.\n\n    ^:!\n      Strict modifier is defined for each pattern type\n    ^:=\n      Equality modifier forces equality to be used, rather than matches?\n    {^:use f}\n      Use mofider forces f to be used as predicate, rather than matches?\n    ^:*\n      Star modifier maps pattern over target, expecting all to match\n    {^:meta m}\n      Meta modifier matches m to the meta of the target\n  ","^3D",["^ ","^37",false,"^3E",2,"^3:",2,"^34",["^S",[["^31"],["^31","^45"]]],"^2[",["^S",[["^31"],["^31","^45"]]],"^36",["^S",[null,null]]]],"^G","~$motif.core/matches?","^6","motif/core.cljc","^:",15,"^3D",["^ ","^37",false,"^3E",2,"^3:",2,"^34",["^S",[["^31"],["^31","^45"]]],"^2[",["^S",[["^31"],["^31","^45"]]],"^36",["^S",[null,null]]],"^34",["^S",[["^31"],["^31","^45"]]],"^35",null,"^3E",2,"^36",["^S",[null,null]],"^8",1,"^37",false,"^3G",[["^ ","^3E",1,"^37",false,"^3H","^39"],["^ ","^3E",2,"^37",false]],"^7",159,"^9",159,"^3:",2,"^3;",true,"^2[",["^S",[["^31"],["^31","^45"]]],"^46","Given a pattern, and an expression, recursively determines\n  if the expression matches the pattern.\n\n  For f, a function, and x, any expression:\n\n    (match f e) => (f e)\n\n  For vector patterns, each ordinal spot is checked:\n\n    (matches? [p0 p1 p2] [t0 t1 t2]) =>\n        [t0 t1 t2 ...]\n          ↑  ↑  ↑      matches?\n        [p0 p1 p2 ...]\n\n    Vectors ensure their targets are at least as long as they are.\n    Strict vectors must have identical lengths.\n\n  For lazy sequence patterns, like vectors, each oridnal spot is checked:\n\n    (matches? (p0 p1 p2) (t0 t1 t2)) =>\n        (t0 t1 t2 ...)\n          ↑  ↑  ↑      matches?\n        (p0 p1 p2 ...)\n\n    Lazy seqs targets can be shorter, or longer, than they are.\n    Infinite sequences can be used, though if they are matched against\n    inifinte targets, a infinte loop will happen\n\n  For m, a map with keyset {k1,k2,...,kn}, and n, a map:\n\n    (match m n) => (and (match (get m k1) (get n k1))\n                        (match (get m k2) (get n k2))\n                        ...\n\n    If the key is an ifn, it will be applied to the target instead.\n    Strict maps require that the pattern contains all keys of the target.\n\n  Set patterns are disjunctive, and only require one of their elements to match.\n\n    (match m n) => (or (match m0 n)\n                       (match m1 n)\n                       ...\n\n    Strict set patterns require exactly one element to match.\n\n  For any pattern not described above, equality is checked.\n\n    (match 1 2) => (= 1 2)\n\n  Given the expression passed matches the given pattern,\n  true will be returned. Otherwise, false will be returned.\n\n\n  Meta tag modifers can enhance and change how each pattern functions.\n\n    ^:!\n      Strict modifier is defined for each pattern type\n    ^:=\n      Equality modifier forces equality to be used, rather than matches?\n    {^:use f}\n      Use mofider forces f to be used as predicate, rather than matches?\n    ^:*\n      Star modifier maps pattern over target, expecting all to match\n    {^:meta m}\n      Meta modifier matches m to the meta of the target\n  "],"~$compile-set",["^ ","^2Y",null,"^5",["^ ","^6","motif/core.cljc","^7",103,"^8",8,"^9",103,"^:",19,"^2Z",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"^2Z",true,"^G","~$motif.core/compile-set","^6","motif/core.cljc","^:",19,"^34",["^S",[["^31","^32"]]],"^35",null,"^36",["^S",[null,null]],"^8",1,"^37",false,"^7",103,"^38","^39","^9",103,"^3:",2,"^3;",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"~$compile-star",["^ ","^2Y",null,"^5",["^ ","^6","motif/core.cljc","^7",24,"^8",8,"^9",24,"^:",20,"^2Z",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"^2Z",true,"^G","~$motif.core/compile-star","^6","motif/core.cljc","^:",20,"^34",["^S",[["^31","^32"]]],"^35",null,"^36",["^S",[null,null]],"^8",1,"^37",false,"^7",24,"^38","^39","^9",24,"^3:",2,"^3;",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"~$compile-use",["^ ","^2Y",null,"^5",["^ ","^6","motif/core.cljc","^7",33,"^8",8,"^9",33,"^:",19,"^2Z",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]],"^2Z",true,"^G","~$motif.core/compile-use","^6","motif/core.cljc","^:",19,"^34",["^S",[["^31","^32"]]],"^35",null,"^36",["^S",[null,null]],"^8",1,"^37",false,"^7",33,"^38","^39","^9",33,"^3:",2,"^3;",true,"^2[",["^S",["^30",["^S",[["^31","^32"]]]]]]],"^Q",["^ ","^M","^M"],"~:cljs.analyzer/constants",["^ ","^O",["^F",["~:*","^5","~:else","~:|","~:use","~:getter","~:&","~:!","~:="]],"~:order",["~:!","^5","~:*","^4@","^4?","^4A","~:|","~:&","~:="]],"^U",["^ "],"^V",["^ "],"^W",["^N","^M"]],"^J","^H","~:ns-specs",["^ "],"~:ns-spec-vars",[],"~:compiler-options",["^19",[["^4E","~:static-fns"],true,["^4E","~:elide-asserts"],false,["^4E","~:optimize-constants"],null,["^4E","^10"],null,["^4E","~:external-config"],null,["^4E","~:tooling-config"],null,["^4E","~:emit-constants"],null,["^4E","~:load-tests"],null,["^4E","~:form-size-threshold"],null,["^4E","~:infer-externs"],true,["^4E","^12"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^4E","~:fn-invoke-direct"],null,["^4E","~:source-map"],"/dev/null"]]]